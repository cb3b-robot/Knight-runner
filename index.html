<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Knight Runner — Local Leaderboard</title>
<style>
:root{--board:600px;--cell:75px;}
*{box-sizing:border-box;}
body{margin:0;background:#111;color:#fff;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;display:flex;flex-direction:column;align-items:center;gap:12px;}
h1{margin:16px 12px 4px;font-size:clamp(20px,3vw,32px);}
.hud{display:flex;gap:14px;align-items:center;font-weight:600;text-shadow:0 1px 2px #0008;}
.pill{padding:6px 10px;border-radius:999px;background:#222;border:1px solid #333;}

#game{
  position:relative;width:var(--board);height:var(--board);
  border:4px solid #fff;border-radius:12px;overflow:hidden;
  box-shadow:0 12px 40px #0008,inset 0 0 0 1px #0006;
}

/* Board */
.square{position:absolute;width:var(--cell);height:var(--cell);}
.light{background:#f0d9b5;}
.dark{background:#b58863;}

/* Pieces */
.piece{position:absolute;width:var(--cell);height:var(--cell);display:flex;align-items:center;justify-content:center;pointer-events:none;user-select:none;}
.knight{z-index:110;color:#fff;font-size:52px;text-shadow:0 2px 6px #0009;}
.enemy{z-index:90;color:#111;font-size:50px;filter:drop-shadow(0 2px 2px rgba(0,0,0,.6));}

/* Knight move dots */
.dot{position:absolute;width:var(--cell);height:var(--cell);display:flex;align-items:center;justify-content:center;z-index:120;cursor:pointer;}
.dot span{width:18px;height:18px;border-radius:50%;background:#2ecc71;box-shadow:0 0 0 3px #2ecc7144,0 2px 6px #0007;}
.dot:active span{transform:scale(.92);}

/* First-arrow highlight */
#arrowHighlight{
  position:absolute;width:var(--cell);height:var(--cell);
  border:2px solid #2ecc71;border-radius:8px;pointer-events:none;
  transition:all .15s ease;z-index:130;display:none;
}

/* Game over overlay */
#over{position:absolute;inset:0;background:rgba(0,0,0,.55);display:none;align-items:center;justify-content:center;flex-direction:column;z-index:200;text-align:center;padding:20px;}
#over h2{margin:0 0 8px;font-size:36px;}
#over p{margin:0 0 12px;opacity:.9;}
#restart{padding:10px 14px;border-radius:10px;border:1px solid #fff4;background:#fff;color:#111;cursor:pointer;font-weight:700;}
#saveRow{display:flex;gap:8px;align-items:center;justify-content:center;margin-top:8px;}
#playerName{padding:8px 10px;border-radius:8px;border:1px solid #444;background:#222;color:#fff;min-width:180px;}
#saveBtn{padding:8px 12px;border-radius:8px;border:1px solid #2ecc71;background:#2ecc71;color:#111;font-weight:700;cursor:pointer;}
#saveBtn[disabled]{opacity:.6;cursor:not-allowed}

/* Leaderboard panel (local) */
#leaderboard{
  width:var(--board);max-width:95vw;background:#1a1a1a;
  border:1px solid #2a2a2a;border-radius:12px;
  box-shadow:0 8px 24px #0007;overflow:hidden;margin:10px 0 16px;
}
#leaderboard header{
  display:flex;justify-content:space-between;align-items:center;
  padding:10px 12px;background:#222;border-bottom:1px solid #2f2f2f;
}
#leaderboard h3{margin:0;font-size:16px;letter-spacing:.4px;}
#lbStatus{opacity:.8;font-size:12px;}
#leaderboard ol{
  list-style:none;margin:0;padding:10px 12px;
  display:grid;grid-template-columns:1fr auto;row-gap:6px;
}
#leaderboard li{display:contents;}
#leaderboard .name{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;padding-right:8px;}
#leaderboard .score{font-variant-numeric:tabular-nums;}

@media (max-width:700px){
  :root{--board:86vw;--cell:calc(var(--board)/8);}
  .knight,.enemy{font-size:calc(var(--cell)*0.7);}
  .dot span{width:calc(var(--cell)*0.24);height:calc(var(--cell)*0.24);}
}
</style>
</head>
<body>
<h1>Knight Runner</h1>
<div class="hud">
  <div class="pill">Score: <span id="score">0.0</span>s</div>
  <div class="pill">Speed: <span id="speed">1.0×</span></div>
</div>
<div id="game"></div>

<!-- Local Leaderboard -->
<div id="leaderboard">
  <header>
    <h3>Leaderboard (Top 10 – this browser)</h3>
    <div id="lbStatus">saved locally</div>
  </header>
  <ol id="lbList"></ol>
</div>

<script>
(() => {
  const game = document.getElementById('game');
  const scoreEl = document.getElementById('score');
  const speedEl = document.getElementById('speed');
  const lbList = document.getElementById('lbList');

  const CELL = 75, SIZE = 8;
  const GLYPHS = { knight:'♞', pawn:'♟', rook:'♜', bishop:'♝', queen:'♛' };

  /* ---------- Local Leaderboard (no backend) ---------- */
  const LS_KEY = 'knightRunnerTopScores_v1';
  function loadScores(){
    try { const raw = localStorage.getItem(LS_KEY); const arr = raw ? JSON.parse(raw) : []; return Array.isArray(arr)?arr:[]; }
    catch { return []; }
  }
  function saveScores(arr){ localStorage.setItem(LS_KEY, JSON.stringify(arr)); }
  function addScore(name, score){
    const list = loadScores();
    list.push({ name: (name||'Player').trim(), score:+score, ts: Date.now() });
    list.sort((a,b)=> b.score - a.score || a.ts - b.ts);
    const top10 = list.slice(0,10);
    saveScores(top10);
    return top10;
  }
  function renderLeaderboard(myName=null, myScore=null){
    lbList.innerHTML='';
    const list = loadScores();
    if(list.length===0){
      const li = document.createElement('li');
      const a = document.createElement('div'); a.className='name'; a.textContent='No scores yet';
      const b = document.createElement('div'); b.className='score'; b.textContent='—';
      lbList.appendChild(li); lbList.appendChild(a); lbList.appendChild(b);
      return;
    }
    list.forEach((e,i)=>{
      const li = document.createElement('li');
      const name = document.createElement('div'); name.className='name';
      const score = document.createElement('div'); score.className='score';
      name.textContent = `${i+1}. ${e.name}`;
      score.textContent = `${e.score.toFixed(1)}s`;
      if(myName && myScore!=null && e.name===myName && Math.abs(e.score-myScore)<1e-6){
        name.style.color = '#2ecc71'; score.style.color = '#2ecc71';
      }
      lbList.appendChild(li); lbList.appendChild(name); lbList.appendChild(score);
    });
  }
  renderLeaderboard();

  /* ---------- Runtime state (declare early) ---------- */
  let running = true;
  let speedMult = 1.0;
  let enemies = [];                 // {el, px, py, type, ...}
  let spawnTimer, difficultyTimer;
  let startTime = performance.now();
  let lastTime  = startTime;

  /* ---------- Board ---------- */
  for (let y=0;y<SIZE;y++){
    for (let x=0;x<SIZE;x++){
      const sq = document.createElement('div');
      sq.className = 'square ' + ((x+y)%2 ? 'dark' : 'light');
      sq.style.left = `${x*CELL}px`;
      sq.style.top  = `${y*CELL}px`;
      game.appendChild(sq);
    }
  }

  /* ---------- Knight ---------- */
  let knight = { x:3, y:6 };
  const knightEl = document.createElement('div');
  knightEl.className = 'piece knight';
  knightEl.textContent = GLYPHS.knight;
  game.appendChild(knightEl);
  const placeKnight = () => {
    knightEl.style.left = `${knight.x*CELL}px`;
    knightEl.style.top  = `${knight.y*CELL}px`;
  };
  placeKnight();

  /* First-arrow highlight */
  const arrowHighlight = document.createElement('div');
  arrowHighlight.id = 'arrowHighlight';
  game.appendChild(arrowHighlight);
  const showArrowHighlight = (dir) => {
    arrowHighlight.style.display='block';
    arrowHighlight.style.left = `${knight.x*CELL + dir.x*CELL}px`;
    arrowHighlight.style.top  = `${knight.y*CELL + dir.y*CELL}px`;
  };
  const hideArrowHighlight = () => { arrowHighlight.style.display='none'; };

  /* ---------- Knight move dots ---------- */
  const knightOffsets = [
    {x:2,y:1},{x:2,y:-1},{x:-2,y:1},{x:-2,y:-1},
    {x:1,y:2},{x:1,y:-2},{x:-1,y:2},{x:-1,y:-2}
  ];
  let dots = [];
  function updateDots(){
    dots.forEach(d=>d.remove()); dots = [];
    if (!running) return;
    for (const o of knightOffsets){
      const tx = knight.x + o.x, ty = knight.y + o.y;
      if (tx<0||tx>=SIZE||ty<0||ty>=SIZE) continue;
      const dot = document.createElement('div');
      dot.className = 'dot';
      dot.style.left = `${tx*CELL}px`;
      dot.style.top  = `${ty*CELL}px`;
      const inner = document.createElement('span'); dot.appendChild(inner);
      dot.addEventListener('click', () => {
        knight.x = tx; knight.y = ty; placeKnight();
        checkCollision(); updateDots();
      });
      game.appendChild(dot); dots.push(dot);
    }
  }

  /* ---------- Enemy behavior ---------- */
  const BASE_SPEED = { pawn:1.15, bishop:2.20, rook:3.00, queen:1.35 }; // cells/sec

  function spawnEnemy(){
    const r = Math.random();
    let type = (r>0.85) ? 'queen' : (r>0.65) ? 'rook' : (r>0.40) ? 'bishop' : 'pawn';
    const x = Math.floor(Math.random()*SIZE), y = -1;

    const el = document.createElement('div');
    el.className = 'piece enemy';
    el.textContent = GLYPHS[type];
    game.appendChild(el);

    const px = x*CELL, py = y*CELL;

    if (type === 'queen') {
      // Queens: step exactly to one of three squares in front (forward-left, forward, forward-right)
      const e = {
        el, type, px, py,
        qx: x, qy: y,            // current cell indices (start row -1)
        qtx: x, qty: 0,          // next target cell
        qtpX: x*CELL, qtpY: 0,   // next target pixel
        stepSpeed: BASE_SPEED.queen
      };
      pickNextQueenTarget(e);
      e.qtpX = e.qtx * CELL; e.qtpY = e.qty * CELL;
      el.style.left = `${px}px`; el.style.top = `${py}px`;
      enemies.push(e);
      return;
    }

    if (type === 'bishop') {
      // Bishops: perfect diagonal stepper (x±1,y+1), bounce at walls; 2× speed
      const dirX = (Math.random()<0.5) ? -1 : 1;
      const e = {
        el, type, px, py,
        bx: x, by: y,
        bdir: dirX,
        btx: x + dirX, bty: 0,
        btpX: (x + dirX) * CELL, btpY: 0,
        stepSpeed: BASE_SPEED.bishop
      };
      if (e.btx < 0 || e.btx >= SIZE) {
        e.bdir = -e.bdir;
        e.btx = e.bx + e.bdir;
        e.btpX = e.btx * CELL;
      }
      el.style.left = `${px}px`; el.style.top = `${py}px`;
      enemies.push(e);
      return;
    }

    // Pawns / Rooks: continuous downward velocity
    let vxCells = 0, vyCells = BASE_SPEED[type];
    if (type === 'rook') { vxCells = 0; vyCells = BASE_SPEED.rook; }
    const e = { el, type, px, py, vxCells, vyCells };
    el.style.left = `${px}px`; el.style.top = `${py}px`;
    enemies.push(e);
  }

  function pickNextQueenTarget(e){
    const cx = e.qx, cy = e.qy, ny = cy + 1;
    const options = [];
    for (const dx of [-1,0,1]) {
      const nx = cx + dx;
      if (nx>=0 && nx<SIZE) options.push(nx);
    }
    const nx = options[Math.floor(Math.random()*options.length)] ?? cx;
    e.qtx = nx; e.qty = ny;
  }
  function pickNextBishopTarget(e){
    const cx = e.bx, cy = e.by;
    let nx = cx + e.bdir;
    const ny = cy + 1;
    if (nx < 0 || nx >= SIZE) { e.bdir = -e.bdir; nx = cx + e.bdir; }
    e.btx = nx; e.bty = ny;
  }

  /* ---------- Difficulty / spawn ---------- */
  const baseSpawnDelay = 1500;
  function scheduleSpawn(){
    const next = Math.max(60, baseSpawnDelay / speedMult);
    spawnTimer = setTimeout(function tick(){
      if (!running) return;
      spawnEnemy();
      scheduleSpawn();
    }, next);
  }
  function scheduleDifficulty(){
    difficultyTimer = setInterval(()=>{
      if (!running) return;
      speedMult += 0.4; // 2× faster ramp, no cap
      speedEl.textContent = `${speedMult.toFixed(1)}×`;
      clearTimeout(spawnTimer);
      scheduleSpawn();
    }, 6000);
  }

  /* ---------- Movement & collisions ---------- */
  function clampX(px){
    if (px < 0) return 0;
    const max = (SIZE-1)*CELL;
    if (px > max) return max;
    return px;
  }

  function moveEnemiesSmooth(dt){
    const dtSec = dt / 1000;

    for (let i=enemies.length-1;i>=0;i--){
      const e = enemies[i];

      if (e.type === 'queen') {
        // Tween toward next selected cell
        const speedPx = e.stepSpeed * CELL * speedMult;
        const dx = e.qtpX - e.px, dy = e.qtpY - e.py;
        const dist = Math.hypot(dx, dy);
        const step = speedPx * dtSec;

        if (dist <= step || dist === 0){
          e.px = e.qtpX; e.py = e.qtpY;
          e.el.style.left = `${e.px}px`; e.el.style.top = `${e.py}px`;
          e.qx = e.qtx; e.qy = e.qty;
          if (e.qy >= SIZE){ e.el.remove(); enemies.splice(i,1); continue; }
          pickNextQueenTarget(e);
          e.qtpX = e.qtx * CELL; e.qtpY = e.qty * CELL;
        } else {
          const ux = dx / dist, uy = dy / dist;
          e.px += ux * step; e.py += uy * step;
          e.el.style.left = `${e.px}px`; e.el.style.top = `${e.py}px`;
        }

      } else if (e.type === 'bishop') {
        // Perfect diagonal step tween
        const speedPx = e.stepSpeed * CELL * speedMult;
        const dx = e.btpX - e.px, dy = e.btpY - e.py;
        const dist = Math.hypot(dx, dy);
        const step = speedPx * dtSec;

        if (dist <= step || dist === 0){
          e.px = e.btpX; e.py = e.btpY;
          e.el.style.left = `${e.px}px`; e.el.style.top = `${e.py}px`;
          e.bx = e.btx; e.by = e.bty;
          if (e.by >= SIZE){ e.el.remove(); enemies.splice(i,1); continue; }
          pickNextBishopTarget(e);
          e.btpX = e.btx * CELL; e.btpY = e.bty * CELL;
        } else {
          const ux = dx / dist, uy = dy / dist;
          e.px += ux * step; e.py += uy * step;
          e.el.style.left = `${e.px}px`; e.el.style.top = `${e.py}px`;
        }

      } else {
        // Pawns/Rooks continuous
        const vx = (e.vxCells||0) * CELL * speedMult;
        const vy = (e.vyCells||0) * CELL * speedMult;
        e.px = clampX(e.px + vx * dtSec);
        e.py += vy * dtSec;
        e.el.style.left = `${e.px}px`;
        e.el.style.top  = `${e.py}px`;
      }

      // Collision (rounded to cells)
      const ex = Math.round(e.px / CELL);
      const ey = Math.round(e.py / CELL);
      if (ex === knight.x && ey === knight.y){ gameOver(); return; }

      // Remove off bottom (safety)
      if (e.py > SIZE*CELL){
        e.el.remove();
        enemies.splice(i,1);
      }
    }
  }

  function checkCollision(){
    if (enemies.some(e => Math.round(e.px/CELL)===knight.x && Math.round(e.py/CELL)===knight.y)){
      gameOver();
    }
  }

  function loop(now){
    if (!running) return;
    const dt = now - lastTime; lastTime = now;
    moveEnemiesSmooth(dt);
    scoreEl.textContent = ((now - startTime)/1000).toFixed(1);
    requestAnimationFrame(loop);
  }

  /* ---------- Keyboard: true knight two-step ---------- */
  const DIRS = { up:{x:0,y:-1}, down:{x:0,y:1}, left:{x:-1,y:0}, right:{x:1,y:0} };
  let arrowStep = 0, firstArrow = null;

  function processArrow(dir){
    if (arrowStep === 0){ firstArrow = dir; arrowStep = 1; showArrowHighlight(dir); return; }
    const dx2 = firstArrow.x * 2, dy2 = firstArrow.y * 2;
    let tx = knight.x, ty = knight.y;

    if (firstArrow.x !== 0 && dir.y !== 0){ tx += dx2; ty += dir.y; }
    else if (firstArrow.y !== 0 && dir.x !== 0){ tx += dir.x; ty += dy2; }
    else if (firstArrow.x === -dir.x && firstArrow.y === -dir.y){ arrowStep=0; firstArrow=null; hideArrowHighlight(); return; }
    else { arrowStep=0; firstArrow=null; hideArrowHighlight(); return; }

    if (tx<0||tx>=SIZE||ty<0||ty>=SIZE){ arrowStep=0; firstArrow=null; hideArrowHighlight(); return; }

    knight.x = tx; knight.y = ty; placeKnight(); checkCollision(); updateDots();
    arrowStep = 0; firstArrow = null; hideArrowHighlight();
  }

  document.addEventListener('keydown', (e)=>{
    if (!running) return;
    const name = e.key.replace('Arrow','').toLowerCase();
    const dir = DIRS[name];
    if (!dir) return;
    processArrow(dir);
  });

  /* ---------- Game over / restart (integrated with leaderboard) ---------- */
  function gameOver(){
    if (!running) return;
    running = false;
    clearTimeout(spawnTimer);
    clearInterval(difficultyTimer);
    if (dots && dots.length) { dots.forEach(d=>d.remove()); dots = []; }
    hideArrowHighlight();

    const over = document.createElement('div');
    over.id='over';
    const finalScore = parseFloat(scoreEl.textContent) || 0;
    over.innerHTML = `
      <h2>Game Over</h2>
      <p>You survived <strong>${finalScore.toFixed(1)}s</strong></p>
      <div id="saveRow">
        <input id="playerName" maxlength="16" placeholder="Your name">
        <button id="saveBtn">Save Score</button>
      </div>
      <button id="restart">Play Again</button>
    `;
    game.appendChild(over);
    over.style.display='flex';

    const nameInput = over.querySelector('#playerName');
    const saveBtn = over.querySelector('#saveBtn');
    const restartBtn = over.querySelector('#restart');

    const lastName = localStorage.getItem('knightRunner_lastName') || '';
    if (lastName) nameInput.value = lastName;

    saveBtn.addEventListener('click', ()=>{
      const name = (nameInput.value || 'Player').trim();
      localStorage.setItem('knightRunner_lastName', name);
      addScore(name, finalScore);
      saveBtn.disabled = true;
      renderLeaderboard(name, finalScore);
    });

    restartBtn.addEventListener('click', restart);
  }

  function restart(){
    enemies.forEach(e=>e.el.remove()); enemies = [];
    const over = document.getElementById('over'); if (over) over.remove();
    speedMult = 1.0; speedEl.textContent = '1.0×';
    startTime = performance.now(); lastTime = startTime;
    knight = {x:3,y:6}; placeKnight();
    arrowStep = 0; firstArrow = null; hideArrowHighlight();
    running = true;
    updateDots();
    clearTimeout(spawnTimer); clearInterval(difficultyTimer);
    scheduleSpawn(); scheduleDifficulty();
    requestAnimationFrame(loop);
  }

  /* ---------- Kickoff ---------- */
  updateDots();
  scheduleSpawn();
  scheduleDifficulty();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
