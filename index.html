<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Knight Runner — Aligned Bishops</title>
<style>
:root{--board:600px;--cell:75px;}
*{box-sizing:border-box;}
body{margin:0;background:#111;color:#fff;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;display:flex;flex-direction:column;align-items:center;gap:12px;}
h1{margin:16px 12px 4px;font-size:clamp(20px,3vw,32px);}
.hud{display:flex;gap:14px;align-items:center;font-weight:600;text-shadow:0 1px 2px #0008;}
.pill{padding:6px 10px;border-radius:999px;background:#222;border:1px solid #333;}

#game{
  position:relative;width:var(--board);height:var(--board);
  border:4px solid #fff;border-radius:12px;overflow:hidden;
  box-shadow:0 12px 40px #0008,inset 0 0 0 1px #0006;
}

/* Board */
.square{position:absolute;width:var(--cell);height:var(--cell);}
.light{background:#f0d9b5;}
.dark{background:#b58863;}

/* Pieces */
.piece{position:absolute;width:var(--cell);height:var(--cell);display:flex;align-items:center;justify-content:center;pointer-events:none;user-select:none;}
.knight{z-index:110;color:#fff;font-size:52px;text-shadow:0 2px 6px #0009;}
.enemy{z-index:90;color:#111;font-size:50px;filter:drop-shadow(0 2px 2px rgba(0,0,0,.6));}

/* Knight move dots */
.dot{position:absolute;width:var(--cell);height:var(--cell);display:flex;align-items:center;justify-content:center;z-index:120;cursor:pointer;}
.dot span{width:18px;height:18px;border-radius:50%;background:#2ecc71;box-shadow:0 0 0 3px #2ecc7144,0 2px 6px #0007;}
.dot:active span{transform:scale(.92);}

/* First-arrow highlight */
#arrowHighlight{
  position:absolute;width:var(--cell);height:var(--cell);
  border:2px solid #2ecc71;border-radius:8px;pointer-events:none;
  transition:all .15s ease;z-index:130;display:none;
}

/* Game over overlay */
#over{position:absolute;inset:0;background:rgba(0,0,0,.55);display:none;align-items:center;justify-content:center;flex-direction:column;z-index:200;text-align:center;padding:20px;}
#over h2{margin:0 0 8px;font-size:36px;}
#over p{margin:0 0 12px;opacity:.9;}
#restart{padding:10px 14px;border-radius:10px;border:1px solid #fff4;background:#fff;color:#111;cursor:pointer;font-weight:700;}

@media (max-width:700px){
  :root{--board:86vw;--cell:calc(var(--board)/8);}
  .knight,.enemy{font-size:calc(var(--cell)*0.7);}
  .dot span{width:calc(var(--cell)*0.24);height:calc(var(--cell)*0.24);}
}
</style>
</head>
<body>
<h1>Knight Runner</h1>
<div class="hud">
  <div class="pill">Score: <span id="score">0.0</span>s</div>
  <div class="pill">Speed: <span id="speed">1.0×</span></div>
</div>
<div id="game"></div>

<script>
(() => {
  const game = document.getElementById('game');
  const scoreEl = document.getElementById('score');
  const speedEl = document.getElementById('speed');

  const CELL = 75, SIZE = 8;
  const GLYPHS = { knight:'♞', pawn:'♟', rook:'♜', bishop:'♝', queen:'♛' };

  /* Runtime state (declare early) */
  let running = true;
  let speedMult = 1.0;
  let enemies = [];                 // generic: {el, px, py, type, ...}
  let spawnTimer, difficultyTimer;
  let startTime = performance.now();
  let lastTime  = startTime;

  /* Board */
  for (let y=0;y<SIZE;y++){
    for (let x=0;x<SIZE;x++){
      const sq = document.createElement('div');
      sq.className = 'square ' + ((x+y)%2 ? 'dark' : 'light');
      sq.style.left = `${x*CELL}px`;
      sq.style.top  = `${y*CELL}px`;
      game.appendChild(sq);
    }
  }

  /* Knight */
  let knight = { x:3, y:6 };
  const knightEl = document.createElement('div');
  knightEl.className = 'piece knight';
  knightEl.textContent = GLYPHS.knight;
  game.appendChild(knightEl);
  const placeKnight = () => {
    knightEl.style.left = `${knight.x*CELL}px`;
    knightEl.style.top  = `${knight.y*CELL}px`;
  };
  placeKnight();

  /* First-arrow highlight */
  const arrowHighlight = document.createElement('div');
  arrowHighlight.id = 'arrowHighlight';
  game.appendChild(arrowHighlight);
  const showArrowHighlight = (dir) => {
    arrowHighlight.style.display='block';
    arrowHighlight.style.left = `${knight.x*CELL + dir.x*CELL}px`;
    arrowHighlight.style.top  = `${knight.y*CELL + dir.y*CELL}px`;
  };
  const hideArrowHighlight = () => { arrowHighlight.style.display='none'; };

  /* Knight move dots */
  const knightOffsets = [
    {x:2,y:1},{x:2,y:-1},{x:-2,y:1},{x:-2,y:-1},
    {x:1,y:2},{x:1,y:-2},{x:-1,y:2},{x:-1,y:-2}
  ];
  let dots = [];
  function updateDots(){
    dots.forEach(d=>d.remove()); dots = [];
    if (!running) return;
    for (const o of knightOffsets){
      const tx = knight.x + o.x, ty = knight.y + o.y;
      if (tx<0||tx>=SIZE||ty<0||ty>=SIZE) continue;
      const dot = document.createElement('div');
      dot.className = 'dot';
      dot.style.left = `${tx*CELL}px`;
      dot.style.top  = `${ty*CELL}px`;
      const inner = document.createElement('span'); dot.appendChild(inner);
      dot.addEventListener('click', () => {
        knight.x = tx; knight.y = ty; placeKnight();
        checkCollision(); updateDots();
      });
      game.appendChild(dot); dots.push(dot);
    }
  }

  /* Enemies: base speeds (cells/sec, scaled by speedMult) */
  const BASE_SPEED = { pawn:1.15, bishop:2.20, rook:3.00, queen:1.35 };

  function spawnEnemy(){
    const r = Math.random();
    let type = (r>0.85) ? 'queen' : (r>0.65) ? 'rook' : (r>0.40) ? 'bishop' : 'pawn';
    const x = Math.floor(Math.random()*SIZE), y = -1;

    const el = document.createElement('div');
    el.className = 'piece enemy';
    el.textContent = GLYPHS[type];
    game.appendChild(el);

    const px = x*CELL, py = y*CELL;

    if (type === 'queen') {
      // Discrete stepper: choose one of three squares in front each row
      const e = {
        el, type,
        px, py,
        qx: x, qy: y,            // current cell indices (queen starts at row -1)
        qtx: x, qty: 0,          // next target cell
        qtpX: x*CELL, qtpY: 0,   // target pixel
        stepSpeed: BASE_SPEED.queen // cells/sec along straight segment
      };
      pickNextQueenTarget(e);
      e.qtpX = e.qtx * CELL; e.qtpY = e.qty * CELL;
      el.style.left = `${px}px`; el.style.top = `${py}px`;
      enemies.push(e);
      return;
    }

    if (type === 'bishop') {
      // Diagonal stepper: always move to the next diagonal cell (x±1,y+1)
      const dirX = (Math.random()<0.5) ? -1 : 1;
      const e = {
        el, type,
        px, py,
        bx: x, by: y,            // current cell indices (bishop starts at row -1)
        bdir: dirX,              // -1 or +1
        btx: x + dirX, bty: 0,   // next target cell (row 0 first)
        btpX: (x + dirX) * CELL, btpY: 0, // target pixel
        stepSpeed: BASE_SPEED.bishop
      };
      // clamp initial if spawning at an edge
      if (e.btx < 0 || e.btx >= SIZE) {
        e.bdir = -e.bdir;
        e.btx = e.bx + e.bdir;
        e.btpX = e.btx * CELL;
      }
      el.style.left = `${px}px`; el.style.top = `${py}px`;
      enemies.push(e);
      return;
    }

    // Pawns / Rooks continuous
    let vxCells = 0, vyCells = BASE_SPEED[type];
    if (type === 'rook') { vxCells = 0; vyCells = BASE_SPEED.rook; }

    const e = { el, type, px, py, vxCells, vyCells };
    el.style.left = `${px}px`; el.style.top = `${py}px`;
    enemies.push(e);
  }

  function pickNextQueenTarget(e){
    // choose from x-1,x,x+1 at next row
    const cx = e.qx, cy = e.qy;
    const ny = cy + 1;
    const options = [];
    for (const dx of [-1,0,1]) {
      const nx = cx + dx;
      if (nx>=0 && nx<SIZE) options.push(nx);
    }
    const nx = options[Math.floor(Math.random()*options.length)] ?? cx;
    e.qtx = nx; e.qty = ny;
  }

  function pickNextBishopTarget(e){
    // next diagonal cell (may bounce at side walls)
    const cx = e.bx, cy = e.by;
    let nx = cx + e.bdir;
    const ny = cy + 1;
    if (nx < 0 || nx >= SIZE) {
      e.bdir = -e.bdir;
      nx = cx + e.bdir;
    }
    e.btx = nx; e.bty = ny;
  }

  /* Difficulty / spawn */
  const baseSpawnDelay = 1500;
  function scheduleSpawn(){
    const next = Math.max(60, baseSpawnDelay / speedMult);
    spawnTimer = setTimeout(function tick(){
      if (!running) return;
      spawnEnemy();
      scheduleSpawn();
    }, next);
  }
  function scheduleDifficulty(){
    difficultyTimer = setInterval(()=>{
      if (!running) return;
      // 2× ramp, no cap
      speedMult += 0.4;
      speedEl.textContent = `${speedMult.toFixed(1)}×`;
      clearTimeout(spawnTimer);
      scheduleSpawn();
    }, 6000);
  }

  /* Movement / collisions */
  function clampX(px){
    if (px < 0) return 0;
    const max = (SIZE-1)*CELL;
    if (px > max) return max;
    return px;
  }

  function moveEnemiesSmooth(dt){
    const dtSec = dt / 1000;

    for (let i=enemies.length-1;i>=0;i--){
      const e = enemies[i];

      if (e.type === 'queen') {
        // Move toward (qtpX,qtpY)
        const speedPx = e.stepSpeed * CELL * speedMult;
        const dx = e.qtpX - e.px;
        const dy = e.qtpY - e.py;
        const dist = Math.hypot(dx, dy);
        const step = speedPx * dtSec;

        if (dist <= step || dist === 0){
          e.px = e.qtpX; e.py = e.qtpY;
          e.el.style.left = `${e.px}px`; e.el.style.top = `${e.py}px`;
          e.qx = e.qtx; e.qy = e.qty;
          if (e.qy >= SIZE){ e.el.remove(); enemies.splice(i,1); continue; }
          pickNextQueenTarget(e);
          e.qtpX = e.qtx * CELL; e.qtpY = e.qty * CELL;
        } else {
          const ux = dx / dist, uy = dy / dist;
          e.px += ux * step; e.py += uy * step;
          e.el.style.left = `${e.px}px`; e.el.style.top = `${e.py}px`;
        }

      } else if (e.type === 'bishop') {
        // Move toward (btpX,btpY) along perfect diagonal (center-to-center)
        const speedPx = e.stepSpeed * CELL * speedMult;
        const dx = e.btpX - e.px;
        const dy = e.btpY - e.py;
        const dist = Math.hypot(dx, dy);
        const step = speedPx * dtSec;

        if (dist <= step || dist === 0){
          e.px = e.btpX; e.py = e.btpY;
          e.el.style.left = `${e.px}px`; e.el.style.top = `${e.py}px`;
          e.bx = e.btx; e.by = e.bty;
          if (e.by >= SIZE){ e.el.remove(); enemies.splice(i,1); continue; }
          pickNextBishopTarget(e);
          e.btpX = e.btx * CELL; e.btpY = e.bty * CELL;
        } else {
          const ux = dx / dist, uy = dy / dist;
          e.px += ux * step; e.py += uy * step;
          e.el.style.left = `${e.px}px`; e.el.style.top = `${e.py}px`;
        }

      } else {
        // Pawns / Rooks (continuous)
        const vx = (e.vxCells||0) * CELL * speedMult;
        const vy = (e.vyCells||0) * CELL * speedMult;
        e.px = clampX(e.px + vx * dtSec);
        e.py += vy * dtSec;
        e.el.style.left = `${e.px}px`;
        e.el.style.top  = `${e.py}px`;
      }

      // Collision (rounded cells)
      const ex = Math.round(e.px / CELL);
      const ey = Math.round(e.py / CELL);
      if (ex === knight.x && ey === knight.y){ gameOver(); return; }

      // Remove off bottom (safety)
      if (e.py > SIZE*CELL){
        e.el.remove();
        enemies.splice(i,1);
      }
    }
  }

  function checkCollision(){
    if (enemies.some(e => Math.round(e.px/CELL)===knight.x && Math.round(e.py/CELL)===knight.y)){
      gameOver();
    }
  }

  function loop(now){
    if (!running) return;
    const dt = now - lastTime; lastTime = now;
    moveEnemiesSmooth(dt);
    scoreEl.textContent = ((now - startTime)/1000).toFixed(1);
    requestAnimationFrame(loop);
  }

  /* Keyboard: true knight two-step */
  const DIRS = { up:{x:0,y:-1}, down:{x:0,y:1}, left:{x:-1,y:0}, right:{x:1,y:0} };
  let arrowStep = 0, firstArrow = null;

  function processArrow(dir){
    if (arrowStep === 0){ firstArrow = dir; arrowStep = 1; showArrowHighlight(dir); return; }
    const dx2 = firstArrow.x * 2, dy2 = firstArrow.y * 2;
    let tx = knight.x, ty = knight.y;

    if (firstArrow.x !== 0 && dir.y !== 0){ tx += dx2; ty += dir.y; }
    else if (firstArrow.y !== 0 && dir.x !== 0){ tx += dir.x; ty += dy2; }
    else if (firstArrow.x === -dir.x && firstArrow.y === -dir.y){ arrowStep=0; firstArrow=null; hideArrowHighlight(); return; }
    else { arrowStep=0; firstArrow=null; hideArrowHighlight(); return; }

    if (tx<0||tx>=SIZE||ty<0||ty>=SIZE){ arrowStep=0; firstArrow=null; hideArrowHighlight(); return; }

    knight.x = tx; knight.y = ty; placeKnight(); checkCollision(); updateDots();
    arrowStep = 0; firstArrow = null; hideArrowHighlight();
  }

  document.addEventListener('keydown', (e)=>{
    if (!running) return;
    const name = e.key.replace('Arrow','').toLowerCase();
    const dir = DIRS[name];
    if (!dir) return;
    processArrow(dir);
  });

  /* Game over / restart */
  function gameOver(){
    if (!running) return;
    running = false;
    clearTimeout(spawnTimer);
    clearInterval(difficultyTimer);
    dots.forEach(d=>d.remove()); dots = [];
    hideArrowHighlight();

    const over = document.createElement('div');
    over.id='over';
    over.innerHTML = `<h2>Game Over</h2>
      <p>You survived <strong>${scoreEl.textContent}s</strong></p>
      <button id="restart">Play Again</button>`;
    game.appendChild(over);
    over.style.display='flex';
    document.getElementById('restart').addEventListener('click', restart);
  }

  function restart(){
    enemies.forEach(e=>e.el.remove()); enemies = [];
    const over = document.getElementById('over'); if (over) over.remove();
    speedMult = 1.0; speedEl.textContent = '1.0×';
    startTime = performance.now(); lastTime = startTime;
    knight = {x:3,y:6}; placeKnight();
    arrowStep = 0; firstArrow = null; hideArrowHighlight();
    running = true;
    updateDots();
    clearTimeout(spawnTimer); clearInterval(difficultyTimer);
    scheduleSpawn(); scheduleDifficulty();
    requestAnimationFrame(loop);
  }

  /* Kickoff */
  updateDots();
  scheduleSpawn();
  scheduleDifficulty();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
