<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Knight Runner — Music, Sounds, Power-ups & Leaderboard</title>
<style>
:root{--board:600px;--cell:75px;}
*{box-sizing:border-box;}
body{margin:0;background:#111;color:#fff;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;display:flex;flex-direction:column;align-items:center;gap:12px;}
h1{margin:16px 12px 4px;font-size:clamp(20px,3vw,32px);}
.hud{display:flex;gap:14px;align-items:center;font-weight:600;text-shadow:0 1px 2px #0008;flex-wrap:wrap;justify-content:center}
.pill{padding:6px 10px;border-radius:999px;background:#222;border:1px solid #333;}
#status{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
.badge{padding:4px 8px;border-radius:999px;border:1px solid #444;background:#1c1c1c;font-size:12px;opacity:.9}
.badge.active{border-color:#2ecc71;box-shadow:0 0 0 2px #2ecc7133 inset}
#muteBtn{padding:6px 10px;border-radius:999px;border:1px solid #444;background:#1c1c1c;color:#fff;cursor:pointer}

/* Game frame */
#game{
  position:relative;width:var(--board);height:var(--board);
  border:4px solid #fff;border-radius:12px;overflow:hidden;
  box-shadow:0 12px 40px #0008,inset 0 0 0 1px #0006;
  transition:transform .12s ease;
}
#game.shake{animation:shake .35s ease;}
@keyframes shake{
  0%,100%{transform:translate3d(0,0,0)}
  20%{transform:translate3d(-6px,0,0)}
  40%{transform:translate3d(6px,0,0)}
  60%{transform:translate3d(-4px,0,0)}
  80%{transform:translate3d(4px,0,0)}
}

/* Board */
.square{position:absolute;width:var(--cell);height:var(--cell);}
.light{background:#f0d9b5;}
.dark{background:#b58863;}

/* Pieces */
.piece{
  position:absolute;width:var(--cell);height:var(--cell);
  display:flex;align-items:center;justify-content:center;
  pointer-events:none;user-select:none;
}
.knight{
  z-index:110;color:#fff;font-size:52px;text-shadow:0 2px 6px #0009;
  transition:left .18s cubic-bezier(.2,.7,.2,1), top .18s cubic-bezier(.2,.7,.2,1), filter .2s ease;
}
.knight.danger{filter:drop-shadow(0 0 10px #e74c3c)}
.enemy{z-index:90;color:#111;font-size:50px;filter:drop-shadow(0 2px 2px rgba(0,0,0,.6));}

/* Power-ups */
.power{position:absolute;z-index:80;width:var(--cell);height:var(--cell);display:flex;align-items:center;justify-content:center;pointer-events:none;}
.power .glyph{font-size:30px;filter:drop-shadow(0 2px 4px #0008)}
.power .ring{position:absolute;width:28px;height:28px;border-radius:50%;box-shadow:0 0 0 3px #fff6 inset,0 0 10px #fff6}
.power.fade{animation:fadeout .45s forwards;}
@keyframes fadeout{to{opacity:0;transform:scale(.9)}}

/* Knight move dots */
.dot{position:absolute;width:var(--cell);height:var(--cell);display:flex;align-items:center;justify-content:center;z-index:120;cursor:pointer;}
.dot span{width:18px;height:18px;border-radius:50%;background:#2ecc71;box-shadow:0 0 0 3px #2ecc7144,0 2px 6px #0007;}
.dot:active span{transform:scale(.92);}

/* First-arrow highlight */
#arrowHighlight{
  position:absolute;width:var(--cell);height:var(--cell);
  border:2px solid #2ecc71;border-radius:8px;pointer-events:none;
  transition:all .15s ease;z-index:130;display:none;
}

/* Game over overlay */
#over{position:absolute;inset:0;background:rgba(0,0,0,.55);display:none;align-items:center;justify-content:center;flex-direction:column;z-index:200;text-align:center;padding:20px;}
#over h2{margin:0 0 8px;font-size:36px;}
#over p{margin:0 0 12px;opacity:.9;}
#restart{padding:10px 14px;border-radius:10px;border:1px solid #fff4;background:#fff;color:#111;cursor:pointer;font-weight:700;}
#saveRow{display:flex;gap:8px;align-items:center;justify-content:center;margin-top:8px;}
#playerName{padding:8px 10px;border-radius:8px;border:1px solid #444;background:#222;color:#fff;min-width:180px;}
#saveBtn{padding:8px 12px;border-radius:8px;border:1px solid #2ecc71;background:#2ecc71;color:#111;font-weight:700;cursor:pointer;}
#saveBtn[disabled]{opacity:.6;cursor:not-allowed}

/* Leaderboard panel (local) */
#leaderboard{
  width:var(--board);max-width:95vw;background:#1a1a1a;
  border:1px solid #2a2a2a;border-radius:12px;
  box-shadow:0 8px 24px #0007;overflow:hidden;margin:10px 0 16px;
}
#leaderboard header{
  display:flex;justify-content:space-between;align-items:center;
  padding:10px 12px;background:#222;border-bottom:1px solid #2f2f2f;
}
#leaderboard h3{margin:0;font-size:16px;letter-spacing:.4px;}
#lbStatus{opacity:.8;font-size:12px;}
#leaderboard ol{
  list-style:none;margin:0;padding:10px 12px;
  display:grid;grid-template-columns:1fr auto;row-gap:6px;
}
#leaderboard li{display:contents;}
#leaderboard .name{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;padding-right:8px;}
#leaderboard .score{font-variant-numeric:tabular-nums;}
#resetScores{
  padding:6px 10px;border-radius:8px;border:1px solid #ff7675;
  background:#ff7675;color:#111;cursor:pointer;font-weight:700;
}
#resetScores:hover{filter:brightness(1.05);}
#resetScores:active{transform:translateY(1px);}

/* Sparkle effect */
.sparkle{position:absolute;pointer-events:none;z-index:150;width:8px;height:8px;border-radius:50%;background:#fff;opacity:.9;animation:spark .5s ease-out forwards;}
@keyframes spark{to{transform:translateY(-12px) scale(.2);opacity:0}}

@media (max-width:700px){
  :root{--board:86vw;--cell:calc(var(--board)/8);}
  .knight,.enemy{font-size:calc(var(--cell)*0.7);}
  .dot span{width:calc(var(--cell)*0.24);height:calc(var(--cell)*0.24);}
}
</style>
</head>
<body>
<h1>Knight Runner</h1>
<div class="hud">
  <div class="pill">Score: <span id="score">0.0</span>s</div>
  <div class="pill">Speed: <span id="speed">1.0×</span></div>
  <div id="status">
    <div class="badge" id="bShield">🛡 shield</div>
    <div class="badge" id="bSpeed">⚡ speed</div>
    <div class="badge" id="bSlow">🕒 slow</div>
    <button id="muteBtn" aria-pressed="false" title="Mute/Unmute">🔊</button>
  </div>
</div>
<div id="game"></div>

<!-- Local Leaderboard -->
<div id="leaderboard">
  <header>
    <h3>Leaderboard (Top 10 – this browser)</h3>
    <div style="display:flex; gap:8px; align-items:center;">
      <div id="lbStatus">saved locally</div>
      <button id="resetScores" title="Clear saved scores">Reset Scores</button>
    </div>
  </header>
  <ol id="lbList"></ol>
</div>

<script>
(() => {
  const game = document.getElementById('game');
  const scoreEl = document.getElementById('score');
  const speedEl = document.getElementById('speed');
  const lbList = document.getElementById('lbList');
  const muteBtn = document.getElementById('muteBtn');

  const bShield = document.getElementById('bShield');
  const bSpeed  = document.getElementById('bSpeed');
  const bSlow   = document.getElementById('bSlow');

  const CELL = 75, SIZE = 8;
  const GLYPHS = { knight:'♞', pawn:'♟', rook:'♜', bishop:'♝', queen:'♛' };

  /* ---------- Audio Engine (SFX + Background Music) ---------- */
  const MUTE_KEY = 'KR_mute';
  let audio = { ctx:null, enabled:true, unlocked:false };
  // restore mute state
  try{ audio.enabled = localStorage.getItem(MUTE_KEY)!=='true' ? true : false; }catch{}
  function ensureAudio(){ if (audio.ctx) return; audio.ctx = new (window.AudioContext||window.webkitAudioContext)(); }
  function unlockAudio(){
    ensureAudio();
    if (audio.unlocked) return;
    const silent = audio.ctx.createBufferSource();
    silent.buffer = audio.ctx.createBuffer(1,1,22050);
    silent.connect(audio.ctx.destination);
    try { silent.start(0); } catch {}
    audio.unlocked = true;
    Music.start(); // start music on first gesture
  }
  function now(){ ensureAudio(); return audio.ctx.currentTime; }
  function tone({freq=440, type='sine', dur=0.12, gain=0.05, attack=0.002, release=0.08, slideTo=null, slideTime=0.08}){
    if (!audio.enabled) return;
    ensureAudio();
    const t0 = now();
    const osc = audio.ctx.createOscillator();
    const g = audio.ctx.createGain();
    const f = audio.ctx.createBiquadFilter();
    f.type = 'lowpass'; f.frequency.value = 8000; // gentle tone
    osc.type = type; osc.frequency.value = freq;
    g.gain.setValueAtTime(0, t0);
    g.gain.linearRampToValueAtTime(gain, t0+attack);
    if (slideTo!=null){ osc.frequency.setValueAtTime(freq, t0); osc.frequency.linearRampToValueAtTime(slideTo, t0+slideTime); }
    g.gain.setValueAtTime(gain, t0+dur);
    g.gain.linearRampToValueAtTime(0.0001, t0+dur+release);
    osc.connect(f); f.connect(g); g.connect(audio.ctx.destination);
    osc.start(t0); osc.stop(t0+dur+release+0.02);
  }
  const SFX = {
    jump(){ tone({freq:600,type:'square',gain:0.04,attack:0.003,release:0.08, slideTo:760, slideTime:0.06}); },
    pickupShield(){ tone({freq:520,type:'triangle',gain:0.05,attack:0.004,release:0.12}); tone({freq:780,type:'triangle',gain:0.04,attack:0.004,release:0.12, slideTo:880, slideTime:0.08}); },
    pickupSpeed(){ tone({freq:750,type:'square',gain:0.05,attack:0.003,release:0.09}); },
    pickupSlow(){ tone({freq:420,type:'sine',gain:0.05,attack:0.003,release:0.18, slideTo:320, slideTime:0.14}); },
    pickupClear(){ tone({freq:300,type:'sawtooth',gain:0.06,attack:0.004,release:0.18, slideTo:120, slideTime:0.2}); },
    spawnPower(){ tone({freq:880,type:'triangle',gain:0.035,attack:0.002,release:0.06}); },
    shieldHit(){ tone({freq:180,type:'square',gain:0.07,attack:0.002,release:0.2}); },
    gameOver(){ tone({freq:440,type:'sawtooth',gain:0.06,attack:0.004,release:0.25, slideTo:180, slideTime:0.25}); },
    restart(){ tone({freq:660,type:'triangle',gain:0.05,attack:0.003,release:0.12, slideTo:880, slideTime:0.08}); }
  };

  // Procedural background music (soft medieval-ish loop)
  // Mode: A minor-ish; simple arpeggios & pads, 8-bar loop (~16s)
  const Music = (() => {
    let master, padGain, arpGain, delay, feedback, lowpass;
    let playing = false, timer = null, step = 0;

    function init() {
      ensureAudio();
      if (master) return;
      master = audio.ctx.createGain();
      padGain = audio.ctx.createGain();
      arpGain = audio.ctx.createGain();
      delay = audio.ctx.createDelay(1.0); delay.delayTime.value = 0.22;
      feedback = audio.ctx.createGain(); feedback.gain.value = 0.25;
      lowpass = audio.ctx.createBiquadFilter(); lowpass.type='lowpass'; lowpass.frequency.value = 2000;

      // gentle volumes
      master.gain.value = 0.18; // global music volume (quiet)
      padGain.gain.value = 0.35;
      arpGain.gain.value = 0.45;

      // wiring: (arp+pad)->lowpass->delay->feedback->lowpass->master->dest
      const dest = audio.ctx.destination;
      const musicBus = audio.ctx.createGain();
      padGain.connect(musicBus); arpGain.connect(musicBus);
      musicBus.connect(lowpass);
      lowpass.connect(delay); delay.connect(feedback); feedback.connect(delay);
      delay.connect(master); lowpass.connect(master);
      master.connect(dest);
    }

    // helper: schedule a short pluck/arp note
    function playNote({freq, when, dur=0.22, type='triangle', gain=0.25, target=arpGain}) {
      if (!audio.enabled) return;
      const osc = audio.ctx.createOscillator();
      const g = audio.ctx.createGain();
      osc.type = type;
      osc.frequency.value = freq;
      g.gain.setValueAtTime(0.0001, when);
      g.gain.linearRampToValueAtTime(gain, when+0.01);
      // slight decay for pluck
      g.gain.exponentialRampToValueAtTime(0.0001, when+dur);
      osc.connect(g); g.connect(target);
      osc.start(when); osc.stop(when+dur+0.02);
    }

    // helper: soft pad chord (two detuned sines)
    function playPad({freq, when, dur=3.8, gain=0.10}) {
      if (!audio.enabled) return;
      const o1 = audio.ctx.createOscillator();
      const o2 = audio.ctx.createOscillator();
      const g = audio.ctx.createGain();
      o1.type='sine'; o2.type='sine';
      o1.frequency.value = freq;
      o2.frequency.value = freq * 2 ** (7/1200); // ~7 cents detune
      const t0 = when;
      g.gain.setValueAtTime(0.0001, t0);
      g.gain.linearRampToValueAtTime(gain, t0+0.8);
      g.gain.linearRampToValueAtTime(0.0001, t0+dur);
      o1.connect(g); o2.connect(g); g.connect(padGain);
      o1.start(t0); o2.start(t0);
      o1.stop(t0+dur+0.1); o2.stop(t0+dur+0.1);
    }

    // scale helper
    function mtof(n){ return 440 * Math.pow(2,(n-69)/12); } // MIDI->freq

    // Simple 16-step pattern; chords Am, F, C, G (i.e., A, F, C, G roots)
    const roots = [57, 53, 60, 55]; // A3, F3, C4, G3
    const arpPattern = [0, 7, 12, 7, 0, 7, 12, 14]; // intervals in semitones
    const stepDur = 0.5; // seconds per step (~120 BPM)

    function tick() {
      if (!playing || !audio.enabled) return;
      const t = now();
      const bar = Math.floor(step / 4);         // 4 steps per bar
      const chordIdx = Math.floor(bar % roots.length);
      const root = roots[chordIdx];

      // every bar, schedule a soft pad root+5th
      if (step % 4 === 0) {
        playPad({freq:mtof(root), when:t+0.01, dur:3.8});
        playPad({freq:mtof(root+7), when:t+0.01, dur:3.8, gain:0.08});
      }

      // arpeggio note this step
      const intv = arpPattern[step % arpPattern.length];
      playNote({freq:mtof(root+intv), when:t+0.02, dur:0.24, type:'triangle', gain:0.18});

      step++;
    }

    function start(){
      init();
      if (playing) return;
      playing = true;
      // run immediately and then on an interval; also schedule one step ahead to avoid drift
      tick();
      timer = setInterval(()=>tick(), stepDur*1000);
    }
    function stop(){
      if (!playing) return;
      playing = false;
      if (timer){ clearInterval(timer); timer = null; }
    }
    function setEnabled(on){
      master && (master.gain.value = on ? 0.18 : 0.0);
    }
    return { start, stop, setEnabled };
  })();

  // Mute toggle
  function applyMuteUI(){
    muteBtn.textContent = audio.enabled ? '🔊' : '🔇';
    muteBtn.setAttribute('aria-pressed', String(!audio.enabled));
    Music.setEnabled(audio.enabled);
  }
  applyMuteUI();

  muteBtn.addEventListener('click', ()=>{
    unlockAudio();
    audio.enabled = !audio.enabled;
    try{ localStorage.setItem(MUTE_KEY, String(!audio.enabled)); }catch{}
    applyMuteUI();
  });
  // Unlock (and start music) on first interaction (mobile-safe)
  ['pointerdown','keydown'].forEach(evt=>document.addEventListener(evt, unlockAudio, {once:true}));

  /* ---------- Local Leaderboard ---------- */
  const LS_KEY = 'knightRunnerTopScores_v1';
  function loadScores(){ try{const raw=localStorage.getItem(LS_KEY);const a=raw?JSON.parse(raw):[];return Array.isArray(a)?a:[]}catch{ return [] } }
  function saveScores(arr){ localStorage.setItem(LS_KEY, JSON.stringify(arr)); }
  function addScore(name, score){
    const list = loadScores();
    list.push({ name:(name||'Player').trim(), score:+score, ts:Date.now() });
    list.sort((a,b)=> b.score - a.score || a.ts - b.ts);
    const top10 = list.slice(0,10); saveScores(top10); return top10;
  }
  function renderLeaderboard(myName=null, myScore=null){
    lbList.innerHTML='';
    const list = loadScores();
    if(list.length===0){
      const li=document.createElement('li'); const a=document.createElement('div'); a.className='name'; a.textContent='No scores yet';
      const b=document.createElement('div'); b.className='score'; b.textContent='—';
      lbList.appendChild(li); lbList.appendChild(a); lbList.appendChild(b); return;
    }
    list.forEach((e,i)=>{
      const li=document.createElement('li');
      const name=document.createElement('div'); name.className='name'; name.textContent=`${i+1}. ${e.name}`;
      const sc=document.createElement('div'); sc.className='score'; sc.textContent=`${e.score.toFixed(1)}s`;
      if(myName && myScore!=null && e.name===myName && Math.abs(e.score-myScore)<1e-6){ name.style.color='#2ecc71'; sc.style.color='#2ecc71'; }
      lbList.appendChild(li); lbList.appendChild(name); lbList.appendChild(sc);
    });
  }
  renderLeaderboard();

  const resetBtn = document.getElementById('resetScores');
  if (resetBtn){
    resetBtn.addEventListener('click', ()=>{
      if (confirm('Clear all saved scores on this browser?')) {
        localStorage.removeItem(LS_KEY);
        renderLeaderboard();
      }
    });
  }

  /* ---------- Game State ---------- */
  let running = true;
  let speedMult = 1.0;
  let slowFactor = 1.0;
  let enemies = [];
  let powerups = [];
  let shield = 0;
  let speedMoves = 0;
  let slowUntil = 0;

  let spawnTimer, difficultyTimer;
  let startTime = performance.now();
  let lastTime  = startTime;

  /* ---------- Board ---------- */
  for (let y=0;y<SIZE;y++){
    for (let x=0;x<SIZE;x++){
      const sq = document.createElement('div');
      sq.className = 'square ' + ((x+y)%2 ? 'dark' : 'light');
      sq.style.left = `${x*CELL}px`;
      sq.style.top  = `${y*CELL}px`;
      game.appendChild(sq);
    }
  }

  /* ---------- Knight ---------- */
  let knight = { x:3, y:6 };
  const knightEl = document.createElement('div');
  knightEl.className = 'piece knight';
  knightEl.textContent = GLYPHS.knight;
  game.appendChild(knightEl);
  const placeKnight = () => { knightEl.style.left = `${knight.x*CELL}px`; knightEl.style.top  = `${knight.y*CELL}px`; };
  placeKnight();

  /* First-arrow highlight */
  const arrowHighlight = document.createElement('div');
  arrowHighlight.id = 'arrowHighlight';
  game.appendChild(arrowHighlight);
  const showArrowHighlight = (dir) => {
    arrowHighlight.style.display='block';
    arrowHighlight.style.left = `${knight.x*CELL + dir.x*CELL}px`;
    arrowHighlight.style.top  = `${knight.y*CELL + dir.y*CELL}px`;
  };
  const hideArrowHighlight = () => { arrowHighlight.style.display='none'; };

  /* ---------- Knight move dots ---------- */
  const knightOffsets = [
    {x:2,y:1},{x:2,y:-1},{x:-2,y:1},{x:-2,y:-1},
    {x:1,y:2},{x:1,y:-2},{x:-1,y:2},{x:-1,y:-2}
  ];
  let dots = [];
  function updateDots(){
    dots.forEach(d=>d.remove()); dots = [];
    if (!running) return;
    for (const o of knightOffsets){
      const tx = knight.x + o.x, ty = knight.y + o.y;
      if (tx<0||tx>=SIZE||ty<0||ty>=SIZE) continue;
      const dot = document.createElement('div'); dot.className = 'dot';
      dot.style.left = `${tx*CELL}px`; dot.style.top  = `${ty*CELL}px`;
      const inner = document.createElement('span'); dot.appendChild(inner);
      dot.addEventListener('click', () => { moveKnightTo(tx, ty); });
      game.appendChild(dot); dots.push(dot);
    }
  }

  /* ---------- Power-ups ---------- */
  const POWER_TYPES = ['shield','speed','slow','clear'];
  const POWER_GLYPH = { shield:'🛡', speed:'⚡', slow:'🕒', clear:'💥' };
  function spawnPowerUp(){
    let tries = 20;
    while (tries-- > 0){
      const x = Math.floor(Math.random()*SIZE);
      const y = Math.floor(Math.random()*(SIZE-1)); // 0..6
      if ((x===knight.x && y===knight.y)) continue;
      if (enemies.some(e => Math.round(e.px/CELL)===x && Math.round(e.py/CELL)===y)) continue;
      const type = POWER_TYPES[Math.floor(Math.random()*POWER_TYPES.length)];
      const el = document.createElement('div'); el.className='power';
      el.style.left = `${x*CELL}px`; el.style.top = `${y*CELL}px`;
      el.innerHTML = `<div class="glyph">${POWER_GLYPH[type]}</div><div class="ring"></div>`;
      game.appendChild(el);
      const expiresAt = performance.now() + 5500;
      powerups.push({el,type,x,y,expiresAt});
      SFX.spawnPower();
      break;
    }
  }
  function pickupAt(x,y){
    for (let i=powerups.length-1;i>=0;i--){
      const p = powerups[i];
      if (p.x===x && p.y===y){
        applyPower(p.type, x, y);
        p.el.classList.add('fade');
        setTimeout(()=>{ p.el.remove(); }, 450);
        powerups.splice(i,1);
      }
    }
  }
  function applyPower(type, x, y){
    sparkle(x,y);
    if (type==='shield'){ shield = 1; bShield.classList.add('active'); SFX.pickupShield(); }
    if (type==='speed'){ speedMoves = 3; bSpeed.classList.add('active'); SFX.pickupSpeed(); }
    if (type==='slow'){ slowUntil = performance.now()+5000; slowFactor = 0.5; bSlow.classList.add('active'); SFX.pickupSlow(); }
    if (type==='clear'){ enemies.forEach(e=>e.el.remove()); enemies = []; SFX.pickupClear(); }
  }
  function sparkle(x,y){
    for(let i=0;i<6;i++){
      const s=document.createElement('div'); s.className='sparkle';
      s.style.left = `${x*CELL + 28 + Math.random()*20}px`;
      s.style.top  = `${y*CELL + 28 + Math.random()*20}px`;
      s.style.background = i%2? '#2ecc71':'#fff';
      game.appendChild(s); setTimeout(()=>s.remove(), 600);
    }
  }

  /* ---------- Enemies ---------- */
  const BASE_SPEED = { pawn:1.15, bishop:2.20, rook:3.00, queen:1.35 }; // cells/sec

  function spawnEnemy(){
    const r = Math.random();
    let type = (r>0.85) ? 'queen' : (r>0.65) ? 'rook' : (r>0.40) ? 'bishop' : 'pawn';
    const x = Math.floor(Math.random()*SIZE), y = -1;

    const el = document.createElement('div');
    el.className = 'piece enemy';
    el.textContent = GLYPHS[type];
    game.appendChild(el);

    const px = x*CELL, py = y*CELL;

    if (type === 'queen') {
      const e = { el, type, px, py, qx:x, qy:y, qtx:x, qty:0, qtpX:x*CELL, qtpY:0, stepSpeed:BASE_SPEED.queen };
      pickNextQueenTarget(e);
      e.qtpX = e.qtx * CELL; e.qtpY = e.qty * CELL;
      el.style.left = `${px}px`; el.style.top = `${py}px`;
      enemies.push(e); return;
    }

    if (type === 'bishop') {
      const dirX = (Math.random()<0.5) ? -1 : 1;
      const e = { el, type, px, py, bx:x, by:y, bdir:dirX, btx:x+dirX, bty:0, btpX:(x+dirX)*CELL, btpY:0, stepSpeed:BASE_SPEED.bishop };
      if (e.btx < 0 || e.btx >= SIZE) { e.bdir = -e.bdir; e.btx = e.bx + e.bdir; e.btpX = e.btx*CELL; }
      el.style.left = `${px}px`; el.style.top = `${py}px`;
      enemies.push(e); return;
    }

    // Pawns / Rooks
    let vxCells = 0, vyCells = BASE_SPEED[type];
    if (type === 'rook') { vxCells = 0; vyCells = BASE_SPEED.rook; }
    const e = { el, type, px, py, vxCells, vyCells };
    el.style.left = `${px}px`; el.style.top = `${py}px`;
    enemies.push(e);
  }

  function pickNextQueenTarget(e){
    const cx = e.qx, cy = e.qy, ny = cy + 1;
    const options = [];
    for (const dx of [-1,0,1]) { const nx = cx + dx; if (nx>=0 && nx<SIZE) options.push(nx); }
    const nx = options[Math.floor(Math.random()*options.length)] ?? cx;
    e.qtx = nx; e.qty = ny;
  }
  function pickNextBishopTarget(e){
    const cx = e.bx, cy = e.by;
    let nx = cx + e.bdir; const ny = cy + 1;
    if (nx < 0 || nx >= SIZE) { e.bdir = -e.bdir; nx = cx + e.bdir; }
    e.btx = nx; e.bty = ny;
  }

  /* ---------- Difficulty / spawn ---------- */
  const baseSpawnDelay = 1500;
  function scheduleSpawn(){
    const next = Math.max(60, baseSpawnDelay / (speedMult * (slowFactor||1)));
    spawnTimer = setTimeout(function tick(){
      if (!running) return;
      if (Math.random() < 0.12) spawnPowerUp(); else spawnEnemy();
      scheduleSpawn();
    }, next);
  }
  function scheduleDifficulty(){
    difficultyTimer = setInterval(()=>{
      if (!running) return;
      speedMult += 0.4;
      speedEl.textContent = `${(speedMult * (slowFactor||1)).toFixed(1)}×`;
      clearTimeout(spawnTimer);
      scheduleSpawn();
    }, 6000);
  }

  /* ---------- Movement & collisions ---------- */
  function clampX(px){
    if (px < 0) return 0;
    const max = (SIZE-1)*CELL;
    if (px > max) return max;
    return px;
  }

  function moveEnemiesSmooth(dt){
    const dtSec = dt / 1000;

    // expire powerups
    const nowT = performance.now();
    for (let i=powerups.length-1;i>=0;i--){
      if (nowT > powerups[i].expiresAt){
        powerups[i].el.classList.add('fade');
        setTimeout(()=>powerups[i].el.remove(), 450);
        powerups.splice(i,1);
      }
    }

    // update slow status
    if (slowUntil && nowT > slowUntil){ slowUntil = 0; slowFactor = 1.0; bSlow.classList.remove('active'); }
    speedEl.textContent = `${(speedMult * (slowFactor||1)).toFixed(1)}×`;

    const effectiveMult = speedMult * (slowFactor||1);

    for (let i=enemies.length-1;i>=0;i--){
      const e = enemies[i];

      if (e.type === 'queen') {
        const speedPx = e.stepSpeed * CELL * effectiveMult;
        const dx = e.qtpX - e.px, dy = e.qtpY - e.py;
        const dist = Math.hypot(dx, dy);
        const step = speedPx * dtSec;

        if (dist <= step || dist === 0){
          e.px = e.qtpX; e.py = e.qtpY; e.el.style.left = `${e.px}px`; e.el.style.top = `${e.py}px`;
          e.qx = e.qtx; e.qy = e.qty;
          if (e.qy >= SIZE){ e.el.remove(); enemies.splice(i,1); continue; }
          pickNextQueenTarget(e); e.qtpX = e.qtx*CELL; e.qtpY = e.qty*CELL;
        } else {
          const ux = dx / dist, uy = dy / dist;
          e.px += ux * step; e.py += uy * step;
          e.el.style.left = `${e.px}px`; e.el.style.top = `${e.py}px`;
        }

      } else if (e.type === 'bishop') {
        const speedPx = e.stepSpeed * CELL * effectiveMult;
        const dx = e.btpX - e.px, dy = e.btpY - e.py;
        const dist = Math.hypot(dx, dy);
        const step = speedPx * dtSec;

        if (dist <= step || dist === 0){
          e.px = e.btpX; e.py = e.btpY; e.el.style.left = `${e.px}px`; e.el.style.top = `${e.py}px`;
          e.bx = e.btx; e.by = e.bty;
          if (e.by >= SIZE){ e.el.remove(); enemies.splice(i,1); continue; }
          pickNextBishopTarget(e); e.btpX = e.btx*CELL; e.btpY = e.bty*CELL;
        } else {
          const ux = dx / dist, uy = dy / dist;
          e.px += ux * step; e.py += uy * step;
          e.el.style.left = `${e.px}px`; e.el.style.top = `${e.py}px`;
        }

      } else {
        // Pawns/Rooks
        const vx = (e.vxCells||0) * CELL * effectiveMult;
        const vy = (e.vyCells||0) * CELL * effectiveMult;
        e.px = clampX(e.px + vx * dtSec);
        e.py += vy * dtSec;
        e.el.style.left = `${e.px}px`;
        e.el.style.top  = `${e.py}px`;
      }

      // Collision
      const ex = Math.round(e.px / CELL);
      const ey = Math.round(e.py / CELL);
      if (ex === knight.x && ey === knight.y){
        if (shield > 0){
          shield = 0; bShield.classList.remove('active');
          e.el.remove(); enemies.splice(i,1);
          game.classList.add('shake'); setTimeout(()=>game.classList.remove('shake'), 220);
          SFX.shieldHit();
          continue;
        } else {
          gameOver(); return;
        }
      }

      // Remove off bottom
      if (e.py > SIZE*CELL){ e.el.remove(); enemies.splice(i,1); }
    }

    // Danger glow (enemy on a knight-reachable square)
    let danger = false;
    for (const o of knightOffsets){
      const tx = knight.x+o.x, ty = knight.y+o.y;
      if (tx<0||tx>=SIZE||ty<0||ty>=SIZE) continue;
      if (enemies.some(e => Math.round(e.px/CELL)===tx && Math.round(e.py/CELL)===ty)){ danger = true; break; }
    }
    knightEl.classList.toggle('danger', danger);
  }

  function checkCollision(){
    if (enemies.some(e => Math.round(e.px/CELL)===knight.x && Math.round(e.py/CELL)===knight.y)){
      if (shield>0){
        shield=0; bShield.classList.remove('active');
        enemies = enemies.filter(e=>!(Math.round(e.px/CELL)===knight.x && Math.round(e.py/CELL)===knight.y));
        SFX.shieldHit();
      } else gameOver();
    }
  }

  /* ---------- Knight movement ---------- */
  function moveKnightTo(tx, ty){
    if (tx<0||tx>=SIZE||ty<0||ty>=SIZE) return;
    knight.x = tx; knight.y = ty; placeKnight();
    SFX.jump();
    pickupAt(tx,ty);
    checkCollision();
    updateDots();
    if (speedMoves>0){ speedMoves--; if (speedMoves===0) bSpeed.classList.remove('active'); }
  }

  /* ---------- Main loop ---------- */
  function loop(now){
    if (!running) return;
    const dt = now - lastTime; lastTime = now;
    moveEnemiesSmooth(dt);
    scoreEl.textContent = ((now - startTime)/1000).toFixed(1);
    requestAnimationFrame(loop);
  }

  /* ---------- Keyboard: true knight two-step ---------- */
  const DIRS = { up:{x:0,y:-1}, down:{x:0,y:1}, left:{x:-1,y:0}, right:{x:1,y:0} };
  let arrowStep = 0, firstArrow = null;

  function processArrow(dir){
    if (arrowStep === 0){ firstArrow = dir; arrowStep = 1; showArrowHighlight(dir); return; }
    const dx2 = firstArrow.x * 2, dy2 = firstArrow.y * 2;
    let tx = knight.x, ty = knight.y;

    if (firstArrow.x !== 0 && dir.y !== 0){ tx += dx2; ty += dir.y; }
    else if (firstArrow.y !== 0 && dir.x !== 0){ tx += dir.x; ty += dy2; }
    else if (firstArrow.x === -dir.x && firstArrow.y === -dir.y){ arrowStep=0; firstArrow=null; hideArrowHighlight(); return; }
    else { arrowStep=0; firstArrow=null; hideArrowHighlight(); return; }

    arrowStep = 0; firstArrow=null; hideArrowHighlight();
    moveKnightTo(tx,ty);
  }

  document.addEventListener('keydown', (e)=>{
    if (!running) return;
    const name = e.key.replace('Arrow','').toLowerCase();
    const dir = DIRS[name];
    if (!dir) return;
    processArrow(dir);
  });

  /* ---------- Game over / restart ---------- */
  function gameOver(){
    if (!running) return;
    running = false;
    clearTimeout(spawnTimer);
    clearInterval(difficultyTimer);
    dots.forEach(d=>d.remove()); dots = [];
    hideArrowHighlight();
    game.classList.add('shake'); setTimeout(()=>game.classList.remove('shake'), 350);
    SFX.gameOver();
    Music.stop(); // pause background music

    const over = document.createElement('div');
    over.id='over';
    const finalScore = parseFloat(scoreEl.textContent) || 0;
    over.innerHTML = `
      <h2>Game Over</h2>
      <p>You survived <strong>${finalScore.toFixed(1)}s</strong></p>
      <div id="saveRow">
        <input id="playerName" maxlength="16" placeholder="Your name">
        <button id="saveBtn">Save Score</button>
      </div>
      <button id="restart">Play Again</button>
    `;
    game.appendChild(over);
    over.style.display='flex';

    const nameInput = over.querySelector('#playerName');
    const saveBtn = over.querySelector('#saveBtn');
    const restartBtn = over.querySelector('#restart');

    const lastName = localStorage.getItem('knightRunner_lastName') || '';
    if (lastName) nameInput.value = lastName;

    saveBtn.addEventListener('click', ()=>{
      const name = (nameInput.value || 'Player').trim();
      localStorage.setItem('knightRunner_lastName', name);
      addScore(name, finalScore);
      saveBtn.disabled = true;
      renderLeaderboard(name, finalScore);
    });

    restartBtn.addEventListener('click', restart);
  }

  function restart(){
    enemies.forEach(e=>e.el.remove()); enemies = [];
    powerups.forEach(p=>p.el.remove()); powerups = [];
    const over = document.getElementById('over'); if (over) over.remove();

    speedMult = 1.0; slowFactor = 1.0; slowUntil = 0;
    shield = 0; speedMoves = 0;
    bShield.classList.remove('active'); bSpeed.classList.remove('active'); bSlow.classList.remove('active');
    speedEl.textContent = '1.0×';
    startTime = performance.now(); lastTime = startTime;
    knight = {x:3,y:6}; placeKnight();
    arrowStep = 0; firstArrow = null; hideArrowHighlight();
    running = true;

    updateDots();
    clearTimeout(spawnTimer); clearInterval(difficultyTimer);
    scheduleSpawn(); scheduleDifficulty();
    requestAnimationFrame(loop);
    SFX.restart();
    Music.start(); // resume background music
  }

  /* ---------- Kickoff ---------- */
  updateDots();
  scheduleSpawn();
  scheduleDifficulty();
  requestAnimationFrame(loop);

  // If user had page muted previously, reflect it
  applyMuteUI();
})();
</script>
</body>
</html>
