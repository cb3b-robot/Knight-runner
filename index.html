<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Knight Runner â€” Power-ups & Effects</title>
<style>
:root{--board:600px;--cell:75px;}
*{box-sizing:border-box;}
body{margin:0;background:#111;color:#fff;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;display:flex;flex-direction:column;align-items:center;gap:12px;}
h1{margin:16px 12px 4px;font-size:clamp(20px,3vw,32px);}
.hud{display:flex;gap:14px;align-items:center;font-weight:600;text-shadow:0 1px 2px #0008;flex-wrap:wrap;justify-content:center}
.pill{padding:6px 10px;border-radius:999px;background:#222;border:1px solid #333;}
#status{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
.badge{padding:4px 8px;border-radius:999px;border:1px solid #444;background:#1c1c1c;font-size:12px;opacity:.9}
.badge.active{border-color:#2ecc71;box-shadow:0 0 0 2px #2ecc7133 inset}

/* Game frame */
#game{
  position:relative;width:var(--board);height:var(--board);
  border:4px solid #fff;border-radius:12px;overflow:hidden;
  box-shadow:0 12px 40px #0008,inset 0 0 0 1px #0006;
  transition:transform .12s ease;
}
#game.shake{animation:shake .35s ease;}
@keyframes shake{
  0%,100%{transform:translate3d(0,0,0)}
  20%{transform:translate3d(-6px,0,0)}
  40%{transform:translate3d(6px,0,0)}
  60%{transform:translate3d(-4px,0,0)}
  80%{transform:translate3d(4px,0,0)}
}

/* Board */
.square{position:absolute;width:var(--cell);height:var(--cell);}
.light{background:#f0d9b5;}
.dark{background:#b58863;}

/* Pieces */
.piece{
  position:absolute;width:var(--cell);height:var(--cell);
  display:flex;align-items:center;justify-content:center;
  pointer-events:none;user-select:none;
}
.knight{
  z-index:110;color:#fff;font-size:52px;text-shadow:0 2px 6px #0009;
  transition:left .18s cubic-bezier(.2,.7,.2,1), top .18s cubic-bezier(.2,.7,.2,1), filter .2s ease;
}
.knight.danger{filter:drop-shadow(0 0 10px #e74c3c)}
.enemy{z-index:90;color:#111;font-size:50px;filter:drop-shadow(0 2px 2px rgba(0,0,0,.6));}

/* Power-ups */
.power{position:absolute;z-index:80;width:var(--cell);height:var(--cell);display:flex;align-items:center;justify-content:center;pointer-events:none;}
.power .glyph{font-size:30px;filter:drop-shadow(0 2px 4px #0008)}
.power .ring{position:absolute;width:28px;height:28px;border-radius:50%;box-shadow:0 0 0 3px #fff6 inset,0 0 10px #fff6}
.power.fade{animation:fadeout .45s forwards;}
@keyframes fadeout{to{opacity:0;transform:scale(.9)}}

/* Knight move dots */
.dot{position:absolute;width:var(--cell);height:var(--cell);display:flex;align-items:center;justify-content:center;z-index:120;cursor:pointer;}
.dot span{width:18px;height:18px;border-radius:50%;background:#2ecc71;box-shadow:0 0 0 3px #2ecc7144,0 2px 6px #0007;}
.dot:active span{transform:scale(.92);}

/* First-arrow highlight */
#arrowHighlight{
  position:absolute;width:var(--cell);height:var(--cell);
  border:2px solid #2ecc71;border-radius:8px;pointer-events:none;
  transition:all .15s ease;z-index:130;display:none;
}

/* Game over overlay */
#over{position:absolute;inset:0;background:rgba(0,0,0,.55);display:none;align-items:center;justify-content:center;flex-direction:column;z-index:200;text-align:center;padding:20px;}
#over h2{margin:0 0 8px;font-size:36px;}
#over p{margin:0 0 12px;opacity:.9;}
#restart{padding:10px 14px;border-radius:10px;border:1px solid #fff4;background:#fff;color:#111;cursor:pointer;font-weight:700;}
#saveRow{display:flex;gap:8px;align-items:center;justify-content:center;margin-top:8px;}
#playerName{padding:8px 10px;border-radius:8px;border:1px solid #444;background:#222;color:#fff;min-width:180px;}
#saveBtn{padding:8px 12px;border-radius:8px;border:1px solid #2ecc71;background:#2ecc71;color:#111;font-weight:700;cursor:pointer;}
#saveBtn[disabled]{opacity:.6;cursor:not-allowed}

/* Leaderboard panel (local) */
#leaderboard{
  width:var(--board);max-width:95vw;background:#1a1a1a;
  border:1px solid #2a2a2a;border-radius:12px;
  box-shadow:0 8px 24px #0007;overflow:hidden;margin:10px 0 16px;
}
#leaderboard header{
  display:flex;justify-content:space-between;align-items:center;
  padding:10px 12px;background:#222;border-bottom:1px solid #2f2f2f;
}
#leaderboard h3{margin:0;font-size:16px;letter-spacing:.4px;}
#lbStatus{opacity:.8;font-size:12px;}
#leaderboard ol{
  list-style:none;margin:0;padding:10px 12px;
  display:grid;grid-template-columns:1fr auto;row-gap:6px;
}
#leaderboard li{display:contents;}
#leaderboard .name{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;padding-right:8px;}
#leaderboard .score{font-variant-numeric:tabular-nums;}
#resetScores{
  padding:6px 10px;border-radius:8px;border:1px solid #ff7675;
  background:#ff7675;color:#111;cursor:pointer;font-weight:700;
}
#resetScores:hover{filter:brightness(1.05);}
#resetScores:active{transform:translateY(1px);}

/* Sparkle effect */
.sparkle{position:absolute;pointer-events:none;z-index:150;width:8px;height:8px;border-radius:50%;background:#fff;opacity:.9;animation:spark .5s ease-out forwards;}
@keyframes spark{to{transform:translateY(-12px) scale(.2);opacity:0}}

@media (max-width:700px){
  :root{--board:86vw;--cell:calc(var(--board)/8);}
  .knight,.enemy{font-size:calc(var(--cell)*0.7);}
  .dot span{width:calc(var(--cell)*0.24);height:calc(var(--cell)*0.24);}
}
</style>
</head>
<body>
<h1>Knight Runner</h1>
<div class="hud">
  <div class="pill">Score: <span id="score">0.0</span>s</div>
  <div class="pill">Speed: <span id="speed">1.0Ã—</span></div>
  <div id="status">
    <div class="badge" id="bShield">ðŸ›¡ shield</div>
    <div class="badge" id="bSpeed">âš¡ speed</div>
    <div class="badge" id="bSlow">ðŸ•’ slow</div>
  </div>
</div>
<div id="game"></div>

<!-- Local Leaderboard -->
<div id="leaderboard">
  <header>
    <h3>Leaderboard (Top 10 â€“ this browser)</h3>
    <div style="display:flex; gap:8px; align-items:center;">
      <div id="lbStatus">saved locally</div>
      <button id="resetScores" title="Clear saved scores">Reset Scores</button>
    </div>
  </header>
  <ol id="lbList"></ol>
</div>

<script>
(() => {
  const game = document.getElementById('game');
  const scoreEl = document.getElementById('score');
  const speedEl = document.getElementById('speed');
  const lbList = document.getElementById('lbList');

  const bShield = document.getElementById('bShield');
  const bSpeed  = document.getElementById('bSpeed');
  const bSlow   = document.getElementById('bSlow');

  const CELL = 75, SIZE = 8;
  const GLYPHS = { knight:'â™ž', pawn:'â™Ÿ', rook:'â™œ', bishop:'â™', queen:'â™›' };

  /* ---------- Local Leaderboard (no backend) ---------- */
  const LS_KEY = 'knightRunnerTopScores_v1';
  function loadScores(){ try{const raw=localStorage.getItem(LS_KEY);const a=raw?JSON.parse(raw):[];return Array.isArray(a)?a:[]}catch{ return [] } }
  function saveScores(arr){ localStorage.setItem(LS_KEY, JSON.stringify(arr)); }
  function addScore(name, score){
    const list = loadScores();
    list.push({ name:(name||'Player').trim(), score:+score, ts:Date.now() });
    list.sort((a,b)=> b.score - a.score || a.ts - b.ts);
    const top10 = list.slice(0,10); saveScores(top10); return top10;
  }
  function renderLeaderboard(myName=null, myScore=null){
    lbList.innerHTML='';
    const list = loadScores();
    if(list.length===0){
      const li=document.createElement('li'); const a=document.createElement('div'); a.className='name'; a.textContent='No scores yet';
      const b=document.createElement('div'); b.className='score'; b.textContent='â€”';
      lbList.appendChild(li); lbList.appendChild(a); lbList.appendChild(b); return;
    }
    list.forEach((e,i)=>{
      const li=document.createElement('li');
      const name=document.createElement('div'); name.className='name'; name.textContent=`${i+1}. ${e.name}`;
      const sc=document.createElement('div'); sc.className='score'; sc.textContent=`${e.score.toFixed(1)}s`;
      if(myName && myScore!=null && e.name===myName && Math.abs(e.score-myScore)<1e-6){ name.style.color='#2ecc71'; sc.style.color='#2ecc71'; }
      lbList.appendChild(li); lbList.appendChild(name); lbList.appendChild(sc);
    });
  }
  renderLeaderboard();

  // Reset Scores button
  const resetBtn = document.getElementById('resetScores');
  if (resetBtn){
    resetBtn.addEventListener('click', ()=>{
      if (confirm('Clear all saved scores on this browser?')) {
        localStorage.removeItem(LS_KEY);
        renderLeaderboard();
      }
    });
  }

  /* ---------- Runtime state (declare early) ---------- */
  let running = true;
  let speedMult = 1.0;
  let slowFactor = 1.0;          // < 1.0 when Slow Time is active
  let enemies = [];              // { ... }
  let powerups = [];             // {el, type, x, y, expiresAt}
  let shield = 0;                // hits remaining
  let speedMoves = 0;            // knight moves remaining with speed boost
  let slowUntil = 0;             // timestamp when slow ends

  let spawnTimer, difficultyTimer;
  let startTime = performance.now();
  let lastTime  = startTime;

  /* ---------- Board ---------- */
  for (let y=0;y<SIZE;y++){
    for (let x=0;x<SIZE;x++){
      const sq = document.createElement('div');
      sq.className = 'square ' + ((x+y)%2 ? 'dark' : 'light');
      sq.style.left = `${x*CELL}px`;
      sq.style.top  = `${y*CELL}px`;
      game.appendChild(sq);
    }
  }

  /* ---------- Knight ---------- */
  let knight = { x:3, y:6 };
  const knightEl = document.createElement('div');
  knightEl.className = 'piece knight';
  knightEl.textContent = GLYPHS.knight;
  game.appendChild(knightEl);
  const placeKnight = () => {
    knightEl.style.left = `${knight.x*CELL}px`;
    knightEl.style.top  = `${knight.y*CELL}px`;
  };
  placeKnight();

  /* First-arrow highlight */
  const arrowHighlight = document.createElement('div');
  arrowHighlight.id = 'arrowHighlight';
  game.appendChild(arrowHighlight);
  const showArrowHighlight = (dir) => {
    arrowHighlight.style.display='block';
    arrowHighlight.style.left = `${knight.x*CELL + dir.x*CELL}px`;
    arrowHighlight.style.top  = `${knight.y*CELL + dir.y*CELL}px`;
  };
  const hideArrowHighlight = () => { arrowHighlight.style.display='none'; };

  /* ---------- Knight move dots ---------- */
  const knightOffsets = [
    {x:2,y:1},{x:2,y:-1},{x:-2,y:1},{x:-2,y:-1},
    {x:1,y:2},{x:1,y:-2},{x:-1,y:2},{x:-1,y:-2}
  ];
  let dots = [];
  function updateDots(){
    dots.forEach(d=>d.remove()); dots = [];
    if (!running) return;
    for (const o of knightOffsets){
      const tx = knight.x + o.x, ty = knight.y + o.y;
      if (tx<0||tx>=SIZE||ty<0||ty>=SIZE) continue;
      const dot = document.createElement('div');
      dot.className = 'dot';
      dot.style.left = `${tx*CELL}px`;
      dot.style.top  = `${ty*CELL}px`;
      const inner = document.createElement('span'); dot.appendChild(inner);
      dot.addEventListener('click', () => { moveKnightTo(tx, ty); });
      game.appendChild(dot); dots.push(dot);
    }
  }

  /* ---------- Power-ups ---------- */
  const POWER_TYPES = ['shield','speed','slow','clear'];
  const POWER_GLYPH = { shield:'ðŸ›¡', speed:'âš¡', slow:'ðŸ•’', clear:'ðŸ’¥' };
  function spawnPowerUp(){
    // pick a random empty board square (top row excluded for clarity)
    let tries = 20;
    while (tries-- > 0){
      const x = Math.floor(Math.random()*SIZE);
      const y = Math.floor(Math.random()*(SIZE-1)); // 0..6
      if ((x===knight.x && y===knight.y)) continue;
      if (enemies.some(e => Math.round(e.px/CELL)===x && Math.round(e.py/CELL)===y)) continue;
      const type = POWER_TYPES[Math.floor(Math.random()*POWER_TYPES.length)];
      const el = document.createElement('div'); el.className='power';
      el.style.left = `${x*CELL}px`; el.style.top = `${y*CELL}px`;
      el.innerHTML = `<div class="glyph">${POWER_GLYPH[type]}</div><div class="ring"></div>`;
      game.appendChild(el);
      const expiresAt = performance.now() + 5500; // ~5.5s life
      powerups.push({el,type,x,y,expiresAt});
      break;
    }
  }
  function pickupAt(x,y){
    for (let i=powerups.length-1;i>=0;i--){
      const p = powerups[i];
      if (p.x===x && p.y===y){
        applyPower(p.type, x, y);
        p.el.classList.add('fade');
        setTimeout(()=>{ p.el.remove(); }, 450);
        powerups.splice(i,1);
      }
    }
  }
  function applyPower(type, x, y){
    sparkle(x,y);
    if (type==='shield'){ shield = 1; bShield.classList.add('active'); }
    if (type==='speed'){ speedMoves = 3; bSpeed.classList.add('active'); }
    if (type==='slow'){ slowUntil = performance.now()+5000; slowFactor = 0.5; bSlow.classList.add('active'); }
    if (type==='clear'){
      enemies.forEach(e=>e.el.remove()); enemies = [];
    }
  }
  function sparkle(x,y){
    for(let i=0;i<6;i++){
      const s=document.createElement('div'); s.className='sparkle';
      s.style.left = `${x*CELL + 28 + Math.random()*20}px`;
      s.style.top  = `${y*CELL + 28 + Math.random()*20}px`;
      s.style.background = i%2? '#2ecc71':'#fff';
      game.appendChild(s); setTimeout(()=>s.remove(), 600);
    }
  }

  /* ---------- Enemy behavior ---------- */
  const BASE_SPEED = { pawn:1.15, bishop:2.20, rook:3.00, queen:1.35 }; // cells/sec

  function spawnEnemy(){
    const r = Math.random();
    let type = (r>0.85) ? 'queen' : (r>0.65) ? 'rook' : (r>0.40) ? 'bishop' : 'pawn';
    const x = Math.floor(Math.random()*SIZE), y = -1;

    const el = document.createElement('div');
    el.className = 'piece enemy';
    el.textContent = GLYPHS[type];
    game.appendChild(el);

    const px = x*CELL, py = y*CELL;

    if (type === 'queen') {
      // Queens: step to one of three squares in front (forward-left, forward, forward-right)
      const e = { el, type, px, py, qx:x, qy:y, qtx:x, qty:0, qtpX:x*CELL, qtpY:0, stepSpeed:BASE_SPEED.queen };
      pickNextQueenTarget(e);
      e.qtpX = e.qtx * CELL; e.qtpY = e.qty * CELL;
      el.style.left = `${px}px`; el.style.top = `${py}px`;
      enemies.push(e); return;
    }

    if (type === 'bishop') {
      // Bishops: perfect diagonal stepper (xÂ±1, y+1) with side bounce
      const dirX = (Math.random()<0.5) ? -1 : 1;
      const e = { el, type, px, py, bx:x, by:y, bdir:dirX, btx:x+dirX, bty:0, btpX:(x+dirX)*CELL, btpY:0, stepSpeed:BASE_SPEED.bishop };
      if (e.btx < 0 || e.btx >= SIZE) { e.bdir = -e.bdir; e.btx = e.bx + e.bdir; e.btpX = e.btx*CELL; }
      el.style.left = `${px}px`; el.style.top = `${py}px`;
      enemies.push(e); return;
    }

    // Pawns / Rooks: continuous downward velocity
    let vxCells = 0, vyCells = BASE_SPEED[type];
    if (type === 'rook') { vxCells = 0; vyCells = BASE_SPEED.rook; }
    const e = { el, type, px, py, vxCells, vyCells };
    el.style.left = `${px}px`; el.style.top = `${py}px`;
    enemies.push(e);
  }

  function pickNextQueenTarget(e){
    const cx = e.qx, cy = e.qy, ny = cy + 1;
    const options = [];
    for (const dx of [-1,0,1]) { const nx = cx + dx; if (nx>=0 && nx<SIZE) options.push(nx); }
    const nx = options[Math.floor(Math.random()*options.length)] ?? cx;
    e.qtx = nx; e.qty = ny;
  }
  function pickNextBishopTarget(e){
    const cx = e.bx, cy = e.by;
    let nx = cx + e.bdir; const ny = cy + 1;
    if (nx < 0 || nx >= SIZE) { e.bdir = -e.bdir; nx = cx + e.bdir; }
    e.btx = nx; e.bty = ny;
  }

  /* ---------- Difficulty / spawn ---------- */
  const baseSpawnDelay = 1500;
  function scheduleSpawn(){
    const next = Math.max(60, baseSpawnDelay / (speedMult * (slowFactor||1)));
    spawnTimer = setTimeout(function tick(){
      if (!running) return;
      // 12% chance to spawn a power-up instead of an enemy
      if (Math.random() < 0.12) spawnPowerUp(); else spawnEnemy();
      scheduleSpawn();
    }, next);
  }
  function scheduleDifficulty(){
    difficultyTimer = setInterval(()=>{
      if (!running) return;
      speedMult += 0.4; // fast ramp, no cap
      speedEl.textContent = `${(speedMult * (slowFactor||1)).toFixed(1)}Ã—`;
      clearTimeout(spawnTimer);
      scheduleSpawn();
    }, 6000);
  }

  /* ---------- Movement & collisions ---------- */
  function clampX(px){
    if (px < 0) return 0;
    const max = (SIZE-1)*CELL;
    if (px > max) return max;
    return px;
  }

  function moveEnemiesSmooth(dt){
    const dtSec = dt / 1000;

    // expire powerups
    const now = performance.now();
    for (let i=powerups.length-1;i>=0;i--){
      if (now > powerups[i].expiresAt){
        powerups[i].el.classList.add('fade');
        setTimeout(()=>powerups[i].el.remove(), 450);
        powerups.splice(i,1);
      }
    }

    // update slow status
    if (slowUntil && now > slowUntil){ slowUntil = 0; slowFactor = 1.0; bSlow.classList.remove('active'); }
    speedEl.textContent = `${(speedMult * (slowFactor||1)).toFixed(1)}Ã—`;

    const effectiveMult = speedMult * (slowFactor||1);

    for (let i=enemies.length-1;i>=0;i--){
      const e = enemies[i];

      if (e.type === 'queen') {
        const speedPx = e.stepSpeed * CELL * effectiveMult;
        const dx = e.qtpX - e.px, dy = e.qtpY - e.py;
        const dist = Math.hypot(dx, dy);
        const step = speedPx * dtSec;

        if (dist <= step || dist === 0){
          e.px = e.qtpX; e.py = e.qtpY; e.el.style.left = `${e.px}px`; e.el.style.top = `${e.py}px`;
          e.qx = e.qtx; e.qy = e.qty;
          if (e.qy >= SIZE){ e.el.remove(); enemies.splice(i,1); continue; }
          pickNextQueenTarget(e); e.qtpX = e.qtx*CELL; e.qtpY = e.qty*CELL;
        } else {
          const ux = dx / dist, uy = dy / dist;
          e.px += ux * step; e.py += uy * step;
          e.el.style.left = `${e.px}px`; e.el.style.top = `${e.py}px`;
        }

      } else if (e.type === 'bishop') {
        const speedPx = e.stepSpeed * CELL * effectiveMult;
        const dx = e.btpX - e.px, dy = e.btpY - e.py;
        const dist = Math.hypot(dx, dy);
        const step = speedPx * dtSec;

        if (dist <= step || dist === 0){
          e.px = e.btpX; e.py = e.btpY; e.el.style.left = `${e.px}px`; e.el.style.top = `${e.py}px`;
          e.bx = e.btx; e.by = e.bty;
          if (e.by >= SIZE){ e.el.remove(); enemies.splice(i,1); continue; }
          pickNextBishopTarget(e); e.btpX = e.btx*CELL; e.btpY = e.bty*CELL;
        } else {
          const ux = dx / dist, uy = dy / dist;
          e.px += ux * step; e.py += uy * step;
          e.el.style.left = `${e.px}px`; e.el.style.top = `${e.py}px`;
        }

      } else {
        // Pawns/Rooks continuous
        const vx = (e.vxCells||0) * CELL * effectiveMult;
        const vy = (e.vyCells||0) * CELL * effectiveMult;
        e.px = clampX(e.px + vx * dtSec);
        e.py += vy * dtSec;
        e.el.style.left = `${e.px}px`;
        e.el.style.top  = `${e.py}px`;
      }

      // Collision (rounded to cells)
      const ex = Math.round(e.px / CELL);
      const ey = Math.round(e.py / CELL);
      if (ex === knight.x && ey === knight.y){
        if (shield > 0){
          shield = 0; bShield.classList.remove('active');
          // destroy that enemy and shake lightly
          e.el.remove(); enemies.splice(i,1);
          game.classList.add('shake'); setTimeout(()=>game.classList.remove('shake'), 220);
          continue;
        } else {
          gameOver(); return;
        }
      }

      // Remove off bottom (safety)
      if (e.py > SIZE*CELL){ e.el.remove(); enemies.splice(i,1); }
    }

    // Danger warning (any enemy can occupy a knight-reachable square next)
    let danger = false;
    for (const o of knightOffsets){
      const tx = knight.x+o.x, ty = knight.y+o.y;
      if (tx<0||tx>=SIZE||ty<0||ty>=SIZE) continue;
      if (enemies.some(e => Math.round(e.px/CELL)===tx && Math.round(e.py/CELL)===ty)){ danger = true; break; }
    }
    knightEl.classList.toggle('danger', danger);
  }

  function checkCollision(){
    if (enemies.some(e => Math.round(e.px/CELL)===knight.x && Math.round(e.py/CELL)===knight.y)){
      if (shield>0){ shield=0; bShield.classList.remove('active'); enemies = enemies.filter(e=>!(Math.round(e.px/CELL)===knight.x && Math.round(e.py/CELL)===knight.y)); }
      else gameOver();
    }
  }

  /* ---------- Knight movement helpers ---------- */
  function moveKnightTo(tx, ty){
    if (tx<0||tx>=SIZE||ty<0||ty>=SIZE) return;
    knight.x = tx; knight.y = ty; placeKnight();
    pickupAt(tx,ty);
    checkCollision();
    updateDots();
    if (speedMoves>0){ speedMoves--; if (speedMoves===0) bSpeed.classList.remove('active'); }
  }

  /* ---------- Main loop ---------- */
  function loop(now){
    if (!running) return;
    const dt = now - lastTime; lastTime = now;
    moveEnemiesSmooth(dt);
    scoreEl.textContent = ((now - startTime)/1000).toFixed(1);
    requestAnimationFrame(loop);
  }

  /* ---------- Keyboard: true knight two-step ---------- */
  const DIRS = { up:{x:0,y:-1}, down:{x:0,y:1}, left:{x:-1,y:0}, right:{x:1,y:0} };
  let arrowStep = 0, firstArrow = null;

  function processArrow(dir){
    if (arrowStep === 0){ firstArrow = dir; arrowStep = 1; showArrowHighlight(dir); return; }
    const dx2 = firstArrow.x * 2, dy2 = firstArrow.y * 2;
    let tx = knight.x, ty = knight.y;

    if (firstArrow.x !== 0 && dir.y !== 0){ tx += dx2; ty += dir.y; }
    else if (firstArrow.y !== 0 && dir.x !== 0){ tx += dir.x; ty += dy2; }
    else if (firstArrow.x === -dir.x && firstArrow.y === -dir.y){ arrowStep=0; firstArrow=null; hideArrowHighlight(); return; }
    else { arrowStep=0; firstArrow=null; hideArrowHighlight(); return; }

    arrowStep = 0; firstArrow=null; hideArrowHighlight();
    moveKnightTo(tx,ty);
  }

  document.addEventListener('keydown', (e)=>{
    if (!running) return;
    const name = e.key.replace('Arrow','').toLowerCase();
    const dir = DIRS[name];
    if (!dir) return;
    // If speed boost active, allow immediate second arrow without waiting? (Handled by transition already)
    processArrow(dir);
  });

  /* ---------- Game over / restart ---------- */
  function gameOver(){
    if (!running) return;
    running = false;
    clearTimeout(spawnTimer);
    clearInterval(difficultyTimer);
    dots.forEach(d=>d.remove()); dots = [];
    hideArrowHighlight();
    game.classList.add('shake'); setTimeout(()=>game.classList.remove('shake'), 350);

    const over = document.createElement('div');
    over.id='over';
    const finalScore = parseFloat(scoreEl.textContent) || 0;
    over.innerHTML = `
      <h2>Game Over</h2>
      <p>You survived <strong>${finalScore.toFixed(1)}s</strong></p>
      <div id="saveRow">
        <input id="playerName" maxlength="16" placeholder="Your name">
        <button id="saveBtn">Save Score</button>
      </div>
      <button id="restart">Play Again</button>
    `;
    game.appendChild(over);
    over.style.display='flex';

    const nameInput = over.querySelector('#playerName');
    const saveBtn = over.querySelector('#saveBtn');
    const restartBtn = over.querySelector('#restart');

    const lastName = localStorage.getItem('knightRunner_lastName') || '';
    if (lastName) nameInput.value = lastName;

    saveBtn.addEventListener('click', ()=>{
      const name = (nameInput.value || 'Player').trim();
      localStorage.setItem('knightRunner_lastName', name);
      addScore(name, finalScore);
      saveBtn.disabled = true;
      renderLeaderboard(name, finalScore);
    });

    restartBtn.addEventListener('click', restart);
  }

  function restart(){
    // cleanup
    enemies.forEach(e=>e.el.remove()); enemies = [];
    powerups.forEach(p=>p.el.remove()); powerups = [];
    const over = document.getElementById('over'); if (over) over.remove();

    // reset state
    speedMult = 1.0; slowFactor = 1.0; slowUntil = 0;
    shield = 0; speedMoves = 0;
    bShield.classList.remove('active'); bSpeed.classList.remove('active'); bSlow.classList.remove('active');
    speedEl.textContent = '1.0Ã—';
    startTime = performance.now(); lastTime = startTime;
    knight = {x:3,y:6}; placeKnight();
    arrowStep = 0; firstArrow = null; hideArrowHighlight();
    running = true;

    updateDots();
    clearTimeout(spawnTimer); clearInterval(difficultyTimer);
    scheduleSpawn(); scheduleDifficulty();
    requestAnimationFrame(loop);
  }

  /* ---------- Kickoff ---------- */
  updateDots();
  scheduleSpawn();
  scheduleDifficulty();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
